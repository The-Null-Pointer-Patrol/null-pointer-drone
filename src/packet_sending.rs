use rand::Rng;
use wg_2024::controller::DroneEvent;
use wg_2024::network::SourceRoutingHeader;
use wg_2024::packet::{Nack, NackType, Packet, PacketType};
use crate::MyDrone;

// packet sending section
impl MyDrone {
    /// takes a packet whose routing header hop index already points to the intended destination
    /// sends that packet through the `channel` corresponding to the current hop index, panics if there is a `SendError`
    pub(crate) fn send_packet(&self, mut packet: Packet) {
        // use hop_idx to get id of destination:
        let dest = packet
            .routing_header
            .current_hop()
            .expect("next hop not found: the internal function packet_send was passed a packet with no destination(its hop_index, which was incremented by 1 to point to dest, was out of bounds for hops)");

        if let Some(channel) = self.packet_send.get(&dest) {
            // packet drop logic
            if matches!(packet.pack_type, PacketType::MsgFragment(_))
                && self.roll_a_dice_and_decide_maybe_drop_packet()
            {
                log::info!("Dropping packet due to drone's pdr");
                packet.routing_header.hop_index -= 1;
                self.make_and_send_nack(
                    &packet,
                    packet.routing_header.hop_index,
                    NackType::Dropped,
                );
                return;
            }

            match channel.send(packet.clone()) {
                Ok(()) => {
                    let drone_event = DroneEvent::PacketSent(packet.clone());
                    self.send_event(&drone_event);
                    log::info!("Sent to channel of Drone#{} Packet {}", dest, &packet,);
                }
                Err(error) => {
                    panic!(
                        "Cannot send packet {} into channel {channel:?}. Error: {error:?}",
                        &packet
                    );
                }
            }
        } else {
            match &packet.pack_type {
                PacketType::MsgFragment(_) => {
                    log::info!(
                        "Next hop of header is not a neighbor of drone, creating {:?}",
                        NackType::ErrorInRouting(dest)
                    );
                    let idx = packet.routing_header.previous_hop().unwrap();
                    self.make_and_send_nack(&packet, idx as usize, NackType::ErrorInRouting(dest));
                }
                PacketType::FloodRequest(_) => {
                    unreachable!("Flood request algorithm should never try to send a flood request to a node not in the list of neighbors, as it gets all the neighbors from that list");
                }
                _ => {
                    log::info!("Sending packet {packet} to simulation controller to shortcut it");
                    let event = DroneEvent::ControllerShortcut(packet);
                    self.send_event(&event);
                }
            }
        };
    }

    /// This method handles the logic of the packet dropping.
    /// It decides to drop a packet or not and, if it does, it creates and sends the related
    /// NACK packet
    fn roll_a_dice_and_decide_maybe_drop_packet(&self) -> bool {
        let mut rng = rand::rng();
        let random_number: f32 = rng.random_range(0.0..=1.0);
        random_number < self.pdr
    }

    /// sends an event to the simulation controller
    /// # Panics
    /// Panics if `self.controller_send.send()` fails
    pub fn send_event(&self, event: &DroneEvent) {
        match self.controller_send.send(event.clone()) {
            Ok(()) => {
                let (event_type, packet) = match event {
                    DroneEvent::PacketSent(packet) => ("PacketSent", packet),
                    DroneEvent::PacketDropped(packet) => ("PacketDropped", packet),
                    DroneEvent::ControllerShortcut(packet) => ("ControllerShortcut", packet),
                };
                log::debug!(
                    "Sent DroneEvent::{} to simulation controller, about packet{}",
                    event_type,
                    packet,
                );
            }
            Err(error) => {
                panic!(
                    "Cannot send event {:?} to simulation controller. Error: {error:?}",
                    &event
                );
            }
        }
    }

    /// all nacks that are generated by this drone pass through here:
    /// creates and sends a nack with the given `NackType`, containing the `original_packet` and reversing the
    /// route so that it goes from `original_recipient_idx` to the node that sent `original_packet`
    /// (the one at index 0)
    pub(crate) fn make_and_send_nack(
        &self,
        original_packet: &Packet,
        original_recipient_idx: usize,
        nack_type: NackType,
    ) {
        //expected to be unreachable given the logic of where make and send nack is done
        assert!(
            original_packet
                .routing_header
                .hops
                .get(original_recipient_idx)
                .is_some(),
            "original recipient index out of bounds, this should be unreachable"
        );

        let fragment_index = match &original_packet.pack_type {
            PacketType::MsgFragment(frag) => frag.fragment_index,
            // if the packet is not a fragment it is considered as a whole so frag index is 0
            _ => 0,
        };

        let nack = Nack {
            fragment_index,
            nack_type,
        };

        let mut new_hops = original_packet.routing_header.hops[0..=original_recipient_idx].to_vec();
        new_hops.reverse();

        let new_header = SourceRoutingHeader {
            hop_index: 1,
            hops: new_hops,
        };
        let packet = Packet {
            pack_type: PacketType::Nack(nack),
            routing_header: new_header,
            session_id: original_packet.session_id,
        };

        if matches!(nack_type, NackType::Dropped) {
            self.send_event(&DroneEvent::PacketDropped(original_packet.clone()));

            // another small detail not too clear in the protocol: here we send the
            // original_packet which had already his hop_index increased so its pointing to
            // where we would have sent him if everything went ok, other option is having
            // hop_index-1 as it was when packet arrived.
        }
        self.send_packet(packet);
    }
}
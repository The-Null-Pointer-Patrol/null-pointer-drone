# null-pointer-drone
The official repository for the drone of the group **null-pointer-patrol**.
# Usage
to use our drone, simply add to your `Cargo.toml`, under `[dependencies]`:
``` rust
null-pointer-drone = { git = "https://github.com/The-Null-Pointer-Patrol/null-pointer-drone.git"}
```
Once you done that you can declare :
``` rust 
use null_pointer_drone::MyDrone; 
```
# After-sales service
if we have any problem with our drone you can still open an issue on our github at [this link](https://github.com/The-Null-Pointer-Patrol/null-pointer-drone/issues)

# Logging
If you don't have a working Simulation Controller yet you can take advantage of the logs generated by our drone to know what's happening inside the network.

You can choose any kind of logging implementation (see https://docs.rs/log/latest/log/#available-logging-implementations). As an example this is how we set the logs up in our network initializer using the crate `simplelog`, and writing them to a file.
``` rust
let log_level = LevelFilter::Info;
let _logger = WriteLogger::init(
    log_level,
    ConfigBuilder::new()
        .set_thread_level(log_level)
        .build(),
    File::create("app.log").expect("Could not create log file"),
);

```
# Drone Logic
## General functioning
The image below is an overwiev of the logic that our drone uses to process packets
![latest2](https://github.com/user-attachments/assets/68793d31-fc32-4103-8fcc-9bbc6711db44)
> The colored squares represent how we split the drone logic in different functions and there are Diamond-shaped decision points for all of the relevant checks that our drone does when processing (except for the panics that are not included in the diagram)

## usefull fonctions
classical fonctions are implemented like **new** or **run**
``` rust
new(
    id: NodeId,
    controller_send: Sender<DroneEvent>,
    controller_recv: Receiver<DroneCommand>,
    packet_recv: Receiver<Packet>,
    packet_send: HashMap<NodeId, Sender<Packet>>,
    pdr: f32,
    ) -> Self;

run();
```

if you want you can also call functions like **set_pdr** or **add_channel***:
```rust
set_pdr(&mut self, pdr: f32)

add_channel(&mut self, id: NodeId, sender: Sender<Packet>)
```

## Implementation details
There are some details in the behavior of our drone that are worth mentioning, often because they handle situations that are not specified in the protocol, and we had to make an independent decision on how to solve them.
### Routing Header validation
When processing the header the drone panics if the routing header is empty or if the hops_index is out of bounds, as we consider these situations unrecoverable. 
### Routing header of flood requests
As seen in the flowchart previously, the drone ignores the contents of the routing header in the flood requests it receives. But, when forwarding a flood request, the drone creates a new header with the hops vector containing only the drone id followed by the id of the drone to which the message will be sent. We believe this makes debugging/visualization better in both in logging and in the simulation controller, and for sure can't affect negatively other drones.
### Nacks
When sending a Nack, that contains a packet, the packet inside will have its hop index pointing to where the drone would have sent that packet if it wasn't for the nack.

